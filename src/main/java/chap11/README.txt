        序列化

        74:谨慎地实现Serializable接口
                实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了"改变这个类的实现"的灵活性。
                实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性。
                实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了。


         75:考虑使用自定义的序列化形式
                如果一个对象的物理表示法等同它的逻辑内容，可能就适合于使用默认的序列化形式。
                即使你确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法以保证约束关系和安全性。

                当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下四个缺点：
                    1:它使这个类的导出API永远地束缚在该类的内部表示法上。
                    2:它会消耗过多的空间
                    3:它会消耗过多的时间
                    4:它会引起栈溢出

         76:保护性地编写readObject方法
                对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组建就属于这一类别。
                对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常，这些检查动作应该跟在所有的保护性拷贝之后。
                如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。
                无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。


         77:对于实例控制，枚举类型优先于readResolve

         78:考虑用序列化代理代替序列化实例
                首先，为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态。这个嵌套类被称作序列化代理，它应该有一个单独的构造器，
                其参数类型就是那个外围类。这个构造器只从它的参数中复制数据:它不需要进行任何一致性检查或者保护性拷贝。