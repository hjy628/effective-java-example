８：　　覆盖equals时请遵守通用约定

    类的每个实例本质上都是唯一的
    不关心类是否提供了“逻辑相等”的测试功能
    超类已经覆盖了equals,从超类继承过来的行为对于子类也是合适的。
    类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用




    equals方法实现了等价关系(equivalence relation)
    自反性 (reflexive) 对于任何非null值的引用值x,x.equals(x)必须返回true.
    对称性(symmetric) 对于任何非null值的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true
    传递性(transitive) 对于任何非null值的引用值x,y和z，如果x.equals(y)返回true,并且y.equals(z)也返回true,那么x.equals(z)也必须返回true.
    一致性(consistent) 对于任何非null值的引用值x和y,只要equals的比较操作在对象中所用的信息没有被修改，多次调用x,equals(y)就会一致性地返回true,或者一致的返回false
    对于任何非null的引用值x,x.equals(null)必须返回false


    我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定,除非愿意放弃面向对象的抽象所带来的优势


    里氏替换原则认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好.


    实现高质量equals方法的诀窍：
        １、使用==操作符检查"参数是否为这个对象的引用"。如果是，则返回true. 这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
        ２、使用instanceof操作符检查"参数是否为正确的类型"
        ３、把参数转换成正确的类型，因为转换之前进行过instanceof测试，所以确保会成功
        ４、对于该类中的每个"关键(significant)"域，检查参数中的域是否与该对象中对应的域相匹配.




    覆盖equals时总要覆盖hashCode
    不要企图让equals方法过于智能
    不要将equals声明中的Object对象替换为其他的类型



======================================================================================================================================

1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。
在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
2.如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象任意一个对象的hashCode方法都必须产生同样的整数结果
2.如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定产生不同的整数结果。


一个好的散列函数通常倾向于"为不相等的对象产生不相等的散列码"

一个简单的把集合中不相等的实例均匀地分布到所有可能的散列值上的简单解决方法:
        1.把某个非零的常数值，比如17,保存在一个名为result的int类型的变量中。
        2.对于对象中每个关键域f(指equals方法中涉及的每个域)，完成以下步骤：
            a.为该域计算int类型的散列码c:
                i. 如果该域是boolean类型，则计算(f?1:0)。
                ii. 如果该域是byte、char、short或者int类型，则计算(int)f。
                iii.如果该域是long类型，则计算(int)(f^(f>>>32))。
                iv.如果该域是float类型，则计算Float.floatToIntBits(f)。
                v.如果该域是double类型，则计算Double.dubleToLongBits(f),然后按照步骤2.a.iii ，为得到的long类型值计算散列值。
                vi.如果该域是一个对象引用，并且该类的equals方法通过递归地调用equals的方式来比较这个域，则同样为这个域递归地调用hashCode。
                如果需要更复杂的比较，则为这个域计算一个"范式",然后针对这个范式调用hashCode,如果这个域的值为null,则返回0(或者其他某个常数，但通常是0)
                vii.如果该域是一个数组，则要把每一个元素当做单独的域来处理，也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的而做法
                把这些散列值组合起来。如果数组域中的每个元素都很重要，可以利用1.5中增加的其中一个Arrays.hashCode方法。
             b.按照下面的公式，把步骤2.a中计算得到的散列码c合并到result中:
                    result = 31 * result + c;
         3.返回result
         4.写完了hashCode方法之后，问问自己"相等的实例是否都具有相等的散列码"




==============================================================================================================================================
10、始终要覆盖toString

11、谨慎地覆盖clone

    cloneable接口的目的是作为对象的一个mixin接口(mixin interface)，表明这样的对象允许克隆(clone)。

 12、考虑实现comparable接口





